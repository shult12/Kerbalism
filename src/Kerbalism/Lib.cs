using CommNet;
using KSP.UI.Screens;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;

namespace KERBALISM
{
	static class Lib
	{
		#region UTILS

		/// <summary> This constant is being set by the build system when a dev release is requested</summary>
#if DEVBUILD
		internal static bool IsDevBuild => true ;
#else
		internal static bool IsDevBuild => false;
#endif

		static Version kerbalismVersion;
		/// <summary> current Kerbalism major/minor version</summary>
		internal static Version KerbalismVersion
		{
			get
			{
				if (kerbalismVersion == null) kerbalismVersion = new Version(Assembly.GetAssembly(typeof(Kerbalism)).GetName().Version.Major, Assembly.GetAssembly(typeof(Kerbalism)).GetName().Version.Minor);
				return kerbalismVersion;
			}
		}

		/// <summary> current KSP version as a "MajorMinor" string</summary>
		internal static string KSPVersionCompact
		{
			get
			{
				return Versioning.version_major.ToString() + Versioning.version_minor.ToString();
			}
		}

		static int kerbalismDevBuild = -1;
		/// <summary>return the current dev build (autogenerated from KerbalismBootstrap AssemblyInfo.cs wildcard)</summary>
		internal static int KerbalismDevBuild
		{
			get
			{
				if (IsDevBuild && kerbalismDevBuild == -1)
				{
					AssemblyLoader.LoadedAssembly bootstrap = AssemblyLoader.loadedAssemblies.FirstOrDefault(p => p.name == "KerbalismBootstrap");
					if (bootstrap != null && bootstrap.assembly != null) kerbalismDevBuild = bootstrap.assembly.GetName().Version.Build;
					else Logging.Log("This is a dev build but KerbalismBootstrap wasn't found!", Logging.LogLevel.Error);
				}
				return kerbalismDevBuild;
			}
		}

		///<summary>return true if an assembly with specified name is loaded</summary>
		internal static bool HasAssembly(string name)
		{
			foreach (var a in AssemblyLoader.loadedAssemblies)
			{
				if (a.name == name) return true;
			}
			return false;
		}

		static bool? hasPrincipia = null;
		static bool HasPrincipia
		{
			get
			{
				if (!hasPrincipia.HasValue)
				{
					hasPrincipia = HasAssembly("ksp_plugin_adapter");
				}
				return hasPrincipia.Value;
			}
		}

		internal static double PrincipiaCorrectInclination(Orbit o)
		{
			if (HasPrincipia && o.referenceBody != (FlightGlobals.currentMainBody ?? Planetarium.fetch.Home))
			{
				Vector3d polarAxis = o.referenceBody.BodyFrame.Z;

				double hSqrMag = o.h.sqrMagnitude;
				if (hSqrMag == 0d)
				{
					return System.Math.Acos(Vector3d.Dot(polarAxis, o.pos) / o.pos.magnitude) * (180.0 / System.Math.PI);
				}
				else
				{
					Vector3d orbitZ = o.h / System.Math.Sqrt(hSqrMag);
					return System.Math.Atan2((orbitZ - polarAxis).magnitude, (orbitZ + polarAxis).magnitude) * (2d * (180.0 / System.Math.PI));
				}
			}
			else
			{
				return o.inclination;
			}
		}

		///<summary>swap two variables</summary>
		internal static void Swap<T>(ref T a, ref T b)
		{
			T tmp = b;
			b = a;
			a = tmp;
		}

		internal static string KerbalismRootPath => Path.Combine(Path.Combine(Path.GetFullPath(KSPUtil.ApplicationRootPath), "GameData"), "Kerbalism");

		///<summary>find a directory in the GameData directory</summary>
		internal static bool GameDirectoryExist(string findpath)
		{
			try
			{
				string gamedir = Path.Combine(Path.GetFullPath(KSPUtil.ApplicationRootPath), "GameData/" + findpath);
				findpath = Path.GetFileName(gamedir);
				gamedir = Path.GetDirectoryName(gamedir);
				string[] paths = System.IO.Directory.GetDirectories(gamedir, findpath, SearchOption.AllDirectories);
				if (paths.Length > 0)
					return true;
				else
					return false;
			}
			catch (Exception e)
			{
				Logging.Log("error while looking for directory '" + findpath + "' in 'GameData' directory. (" + e.Message + ")");
				return false;
			}
		}
		#endregion

		#region HASH
		///<summary>combine two guid, irregardless of their order (eg: Combine(a,b) == Combine(b,a))</summary>
		internal static Guid CombineGuid(Guid a, Guid b)
		{
			byte[] a_buf = a.ToByteArray();
			byte[] b_buf = b.ToByteArray();
			byte[] c_buf = new byte[16];
			for (int i = 0; i < 16; ++i) c_buf[i] = (byte)(a_buf[i] ^ b_buf[i]);
			return new Guid(c_buf);
		}

		///<summary>combine two guid, in a non-commutative way</summary>
		internal static Guid OrderedCombineGuid(Guid a, Guid b)
		{
			byte[] a_buf = a.ToByteArray();
			byte[] b_buf = b.ToByteArray();
			byte[] c_buf = new byte[16];
			for (int i = 0; i < 16; ++i) c_buf[i] = (byte)(a_buf[i] & ~b_buf[i]);
			return new Guid(c_buf);
		}

		///<summary>get 32bit FNV-1a hash of a string</summary>
		internal static UInt32 Hash32(string s)
		{
			// offset basis
			UInt32 h = 2166136261u;

			// for each byte of the buffer
			for (int i = 0; i < s.Length; ++i)
			{
				// xor the bottom with the current octet
				h ^= s[i];

				// equivalent to h *= 16777619 (FNV magic prime mod 2^32)
				h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
			}

			//return the hash
			return h;
		}
		#endregion

		#region STRING
		/// <summary> return string limited to len, with ... at the end</summary>
		internal static string Ellipsis(string s, uint len)
		{
			len = System.Math.Max(len, 3u);
			return s.Length <= len ? s : Lib.BuildString(s.Substring(0, (int)len - 3), "...");
		}

		/// <summary> return string limited to len, with ... in the middle</summary>
		internal static string EllipsisMiddle(string s, int len)
		{
			if (s.Length > len)
			{
				len = (len - 3) / 2;
				return Lib.BuildString(s.Substring(0, len), "...", s.Substring(s.Length - len));
			}
			return s;
		}

		///<summary>tokenize a string</summary>
		internal static List<string> Tokenize(string txt, char separator)
		{
			List<string> ret = new List<string>();
			string[] strings = txt.Split(separator);
			foreach (string s in strings)
			{
				string trimmed = s.Trim();
				if (trimmed.Length > 0) ret.Add(trimmed);
			}
			return ret;
		}

		///<summary>
		/// return message with the macro expanded
		///- variant: tokenize the string by '|' and select one
		///</summary>
		internal static string ExpandMsg(string txt, Vessel v = null, ProtoCrewMember c = null, uint variant = 0)
		{
			// get variant
			var variants = txt.Split('|');
			if (variants.Length > variant) txt = variants[variant];

			// macro expansion
			string v_name = v != null ? (v.isEVA ? "EVA" : v.vesselName) : "";
			string c_name = c != null ? c.name : "";
			return txt
			  .Replace("@", "\n")
			  .Replace("$VESSEL", BuildString("<b>", v_name, "</b>"))
			  .Replace("$KERBAL", "<b>" + c_name + "</b>")
			  .Replace("$ON_VESSEL", v != null && v.isActiveVessel ? "" : BuildString("On <b>", v_name, "</b>, "))
			  .Replace("$HIS_HER", c != null && c.gender == ProtoCrewMember.Gender.Male ? Local.Kerbal_his : Local.Kerbal_her);//"his""her"
		}

		///<summary>make the first letter uppercase</summary>
		internal static string UppercaseFirst(string s)
		{
			return s.Length > 0 ? char.ToUpper(s[0]) + s.Substring(1) : string.Empty;
		}

		///<summary>standardized kerbalism string colors</summary>
		internal enum Kolor
		{
			None,
			Green,
			Yellow,
			Orange,
			Red,
			PosRate,
			NegRate,
			Science,
			Cyan,
			LightGrey,
			DarkGrey
		}

		///<summary>return a colored "[V]" or "[X]" depending on the condition. Only work if placed at the begining of a line. To align other lines, use the "<pos=5em>" tag</summary>
		internal static string Checkbox(bool condition)
		{
			return condition
				? " <color=#88FF00><mark=#88FF0033><mspace=1em><b><i>V </i></b></mspace></mark></color><pos=5em>"
				: " <color=#FF8000><mark=#FF800033><mspace=1em><b><i>X </i></b></mspace></mark></color><pos=5em>";
		}

		///<summary>return the hex representation for kerbalism Kolors</summary>
		static string KolorToHex(Kolor color)
		{
			switch (color)
			{
				case Kolor.None:		return "#FFFFFF"; // use this in the Color() methods if no color tag is to be applied
				case Kolor.Green:		return "#88FF00"; // green whith slightly less red than the ksp ui default (CCFF00), for better contrast with yellow
				case Kolor.Yellow:		return "#FFD200"; // ksp ui yellow
				case Kolor.Orange:		return "#FF8000"; // ksp ui orange
				case Kolor.Red:		    return "#FF3333"; // custom red
				case Kolor.PosRate:	    return "#88FF00"; // green
				case Kolor.NegRate:	    return "#FF8000"; // orange
				case Kolor.Science:	    return "#6DCFF6"; // ksp science color
				case Kolor.Cyan:		return "#00FFFF"; // cyan
				case Kolor.LightGrey:	return "#CCCCCC"; // light grey
				case Kolor.DarkGrey:	return "#999999"; // dark grey	
				default:				return "#FEFEFE";
			}
		}

		///<summary>return the unity Colot  for kerbalism Kolors</summary>
		internal static Color KolorToColor(Kolor color)
		{
			switch (color)
			{
				case Kolor.None:      return new Color(1.000f, 1.000f, 1.000f); 
				case Kolor.Green:     return new Color(0.533f, 1.000f, 0.000f);
				case Kolor.Yellow:    return new Color(1.000f, 0.824f, 0.000f);
				case Kolor.Orange:    return new Color(1.000f, 0.502f, 0.000f);
				case Kolor.Red:       return new Color(1.000f, 0.200f, 0.200f);
				case Kolor.PosRate:   return new Color(0.533f, 1.000f, 0.000f);
				case Kolor.NegRate:   return new Color(1.000f, 0.502f, 0.000f);
				case Kolor.Science:   return new Color(0.427f, 0.812f, 0.965f);
				case Kolor.Cyan:      return new Color(0.000f, 1.000f, 1.000f);
				case Kolor.LightGrey: return new Color(0.800f, 0.800f, 0.800f);
				case Kolor.DarkGrey:  return new Color(0.600f, 0.600f, 0.600f);
				default:              return new Color(1.000f, 1.000f, 1.000f);
			}
		}

		///<summary>return string with the specified color and bold if stated</summary>
		internal static string Color(string s, Kolor color, bool bold = false)
		{
			return !bold ? BuildString("<color=", KolorToHex(color), ">", s, "</color>") : BuildString("<color=", KolorToHex(color), "><b>", s, "</b></color>");
		}

		///<summary>return string with different colors depending on the specified condition. "KColor.Default" will not apply any coloring</summary>
		internal static string Color(bool condition, string s, Kolor colorIfTrue, Kolor colorIfFalse = Kolor.None, bool bold = false)
		{
			return condition ? Color(s, colorIfTrue, bold) : colorIfFalse == Kolor.None ? bold ? Bold(s) : s : Color(s, colorIfFalse, bold);
		}

		///<summary>return different colored strings depending on the specified condition. "KColor.Default" will not apply any coloring</summary>
		internal static string Color(bool condition, string sIfTrue, Kolor colorIfTrue, string sIfFalse, Kolor colorIfFalse = Kolor.None, bool bold = false)
		{
			return condition ? Color(sIfTrue, colorIfTrue, bold) : colorIfFalse == Kolor.None ? bold ? Bold(sIfFalse) : sIfFalse : Color(sIfFalse, colorIfFalse, bold);
		}

		///<summary>return string in bold</summary>
		internal static string Bold(string s)
		{
			return BuildString("<b>", s, "</b>");
		}


		///<summary>return string in italic</summary>
		internal static string Italic(string s)
		{
			return BuildString("<i>", s, "</i>");
		}

		///<summary>add spaces on caps</summary>
		internal static string SpacesOnCaps(string s)
		{
			return System.Text.RegularExpressions.Regex.Replace(s, "[A-Z]", " $0").TrimStart();
		}

		///<summary>convert to smart_case</summary>
		internal static string SmartCase(string s)
		{
			return SpacesOnCaps(s).ToLower().Replace(' ', '_');
		}

		///<summary>converts_from_this to this</summary>
		internal static string SpacesOnUnderscore(string s)
		{
			return s.Replace('_', ' ');
		}


		///<summary>select a string at random</summary>
		internal static string TextVariant(params string[] list)
		{
			return list.Length == 0 ? string.Empty : list[Random.RandomInt(list.Length)];
		}


		/// <summary> insert lines break to have a max line length of 'maxCharPerLine' characters </summary>
		internal static string WordWrapAtLength(string longText, int maxCharPerLine)
		{

			longText = longText.Replace("\n", "");
			int currentPosition = 0;
			int textLength = longText.Length;
			while (true)
			{
				// if the remaining text is shorter that maxCharPerLine, return.
				if (currentPosition + maxCharPerLine >= textLength)
					break;

				// get position of first space before maxCharPerLine
				int nextSpacePosition = longText.LastIndexOf(' ', currentPosition + maxCharPerLine);

				// we found a space in the next line, replace it with a new line
				if (nextSpacePosition > currentPosition)
				{
					char[] longTextArray = longText.ToCharArray();
					longTextArray[nextSpacePosition] = '\n';
					longText = new string(longTextArray);
					currentPosition = nextSpacePosition;

				}
				// else break the word
				else
				{
					nextSpacePosition = currentPosition + maxCharPerLine;
					longText = longText.Insert(nextSpacePosition, "-\n");
					textLength += 2;
					currentPosition = nextSpacePosition + 2;
				}
			}
			return longText;

		}
		#endregion

		#region BUILD STRING
		// compose a set of strings together, without creating temporary objects
		// note: the objective here is to minimize number of temporary variables for GC
		// note: okay to call recursively, as long as all individual concatenation is atomic
		static StringBuilder sb = new StringBuilder(256);
		internal static string BuildString(string a, string b)
		{
			sb.Length = 0;
			sb.Append(a);
			sb.Append(b);
			return sb.ToString();
		}
		internal static string BuildString(string a, string b, string c)
		{
			sb.Length = 0;
			sb.Append(a);
			sb.Append(b);
			sb.Append(c);
			return sb.ToString();
		}
		internal static string BuildString(string a, string b, string c, string d)
		{
			sb.Length = 0;
			sb.Append(a);
			sb.Append(b);
			sb.Append(c);
			sb.Append(d);
			return sb.ToString();
		}
		internal static string BuildString(string a, string b, string c, string d, string e)
		{
			sb.Length = 0;
			sb.Append(a);
			sb.Append(b);
			sb.Append(c);
			sb.Append(d);
			sb.Append(e);
			return sb.ToString();
		}
		internal static string BuildString(string a, string b, string c, string d, string e, string f)
		{
			sb.Length = 0;
			sb.Append(a);
			sb.Append(b);
			sb.Append(c);
			sb.Append(d);
			sb.Append(e);
			sb.Append(f);
			return sb.ToString();
		}
		internal static string BuildString(string a, string b, string c, string d, string e, string f, string g)
		{
			sb.Length = 0;
			sb.Append(a);
			sb.Append(b);
			sb.Append(c);
			sb.Append(d);
			sb.Append(e);
			sb.Append(f);
			sb.Append(g);
			return sb.ToString();
		}
		internal static string BuildString(string a, string b, string c, string d, string e, string f, string g, string h)
		{
			sb.Length = 0;
			sb.Append(a);
			sb.Append(b);
			sb.Append(c);
			sb.Append(d);
			sb.Append(e);
			sb.Append(f);
			sb.Append(g);
			sb.Append(h);
			return sb.ToString();
		}
		internal static string BuildString(params string[] args)
		{
			sb.Length = 0;
			foreach (string s in args) sb.Append(s);
			return sb.ToString();
		}
		#endregion

		#region BODY

		/// <summary>For a given body, return the last parent body that is not a sun </summary>
		internal static CelestialBody GetParentPlanet(CelestialBody body)
		{
			if (Lib.IsSun(body)) return body;
			CelestialBody checkedBody = body;
			while (!Lib.IsSun(checkedBody.referenceBody)) checkedBody = checkedBody.referenceBody;
			return checkedBody;
		}

		/// <summary> optimized method for getting normalized direction and distance between the surface of two bodies</summary>
		/// <param name="direction">normalized vector 'from' body 'to' body</param>
		/// <param name="distance">distance between the body surface</param>
		static void DirectionAndDistance(CelestialBody from, CelestialBody to, out Vector3d direction, out double distance)
		{
			Lib.DirectionAndDistance(from.position, to.position, out direction, out distance);
			distance -= from.Radius + to.Radius;
		}

		/// <summary> optimized method for getting normalized direction and distance between a world position and the surface of a body</summary>
		/// <param name="direction">normalized vector 'from' position 'to' body</param>
		/// <param name="distance">distance to the body surface</param>
		internal static void DirectionAndDistance(Vector3d from, CelestialBody to, out Vector3d direction, out double distance)
		{
			Lib.DirectionAndDistance(from, to.position, out direction, out distance);
			distance -= to.Radius;
		}

		/// <summary> optimized method for getting normalized direction and distance between two world positions</summary>
		/// <param name="direction">normalized vector 'from' position 'to' position</param>
		/// <param name="distance">distance between the body surface</param>
		static void DirectionAndDistance(Vector3d from, Vector3d to, out Vector3d direction, out double distance)
		{
			direction = to - from;
			distance = direction.magnitude;
			direction /= distance;
		}

		/// <summary> Is this body a sun ? </summary>
		internal static bool IsSun(CelestialBody body)
		{
			return Sim.suns.Exists(p => p.bodyIndex == body.flightGlobalsIndex);
		}

		/// <summary> return the first found parent sun for a given body </summary>
		internal static CelestialBody GetParentSun(CelestialBody body)
		{
			if (IsSun(body)) return body;

			CelestialBody refBody = body.referenceBody;
			do
			{
				if (IsSun(refBody)) return refBody;
				refBody = refBody.referenceBody;
			}
			while (refBody != null);

			return FlightGlobals.Bodies[0];
		}

		///<summary
		/// return selected body in tracking-view/map-view
		/// >if a vessel is selected, return its main body
		///</summary>
		internal static CelestialBody MapViewSelectedBody()
		{
			var target = PlanetariumCamera.fetch.target;
			return
				target == null ? null : target.celestialBody ?? target.vessel?.mainBody;
		}

		/* this appears to be broken / working unreliably, use a raycast instead
		/// <summary
		/// return terrain height at point specified
		///- body terrain must be loaded for this to work: use it only for loaded vessels
		/// </summary>
		public static double TerrainHeight(CelestialBody body, Vector3d pos)
		{
			PQS pqs = body.pqsController;
			if (pqs == null) return 0.0;
			Vector2d latlong = body.GetLatitudeAndLongitude(pos);
			Vector3d radial = QuaternionD.AngleAxis(latlong.y, Vector3d.down) * QuaternionD.AngleAxis(latlong.x, Vector3d.forward) * Vector3d.right;
			return (pos - body.position).magnitude - pqs.GetSurfaceHeight(radial);
		}
		*/
		#endregion

		#region VESSEL
		///<summary>return true if landed somewhere</summary>
		internal static bool Landed(Vessel v)
		{
			if (v.loaded) return v.Landed || v.Splashed;
			else return v.protoVessel.landed || v.protoVessel.splashed;
		}

		///<summary>return vessel position</summary>
		internal static Vector3d VesselPosition(Vessel v)
		{
			// the issue
			//   - GetWorldPos3D() return mainBody position for a few ticks after scene changes
			//   - we can detect that, and fall back to evaluating position from the orbit
			//   - orbit is not valid if the vessel is landed, and for a tick on prelaunch/staging/decoupling
			//   - evaluating position from latitude/longitude work in all cases, but is probably the slowest method

			// get vessel position
			Vector3d pos = v.GetWorldPos3D();

			// during scene changes, it will return mainBody position
			if (Vector3d.SqrMagnitude(pos - v.mainBody.position) < 1.0)
			{
				// try to get it from orbit
				pos = v.orbit.getPositionAtUT(Planetarium.GetUniversalTime());

				// if the orbit is invalid (landed, or 1 tick after prelaunch/staging/decoupling)
				if (double.IsNaN(pos.x))
				{
					// get it from lat/long (work even if it isn't landed)
					pos = v.mainBody.GetWorldSurfacePosition(v.latitude, v.longitude, v.altitude);
				}
			}

			// victory
			return pos;
		}


		///<summary>return set of crew on a vessel. Works on loaded and unloaded vessels</summary>
		internal static List<ProtoCrewMember> CrewList(Vessel v)
		{
			return v.loaded ? v.GetVesselCrew() : v.protoVessel.GetVesselCrew();
		}

		///<summary>return crew count of a vessel. Works on loaded and unloaded vessels</summary>
		internal static int CrewCount(Vessel v)
		{
			return v.isEVA ? 1 : CrewList(v).Count;
		}

		///<summary>return crew count of a protovessel</summary>
		internal static int CrewCount(ProtoVessel pv)
		{
			if (pv == null)
				return 0;

			return pv.vesselType == VesselType.EVA ? 1 : pv.GetVesselCrew().Count();
		}

		///<summary>return crew capacity of a vessel</summary>
		internal static int CrewCapacity(Vessel v)
		{
			if (v.isEVA) return 1;
			if (v.loaded)
			{
				return v.GetCrewCapacity();
			}
			else
			{
				int capacity = 0;
				foreach (ProtoPartSnapshot p in v.protoVessel.protoPartSnapshots)
				{
					capacity += p.partInfo.partPrefab.CrewCapacity;
				}
				return capacity;
			}
		}


		///<summary>return true if this is a 'vessel'</summary>
		internal static bool IsVessel(Vessel v)
		{
			// something weird is going on
			if (v == null) return false;

			// if the vessel is in DEAD status, we consider it invalid
			if (v.state == Vessel.State.DEAD) return false;

			// if the vessel is a debris, a flag or an asteroid, ignore it
			// - the user can change vessel type, in that case he is actually disabling this mod for the vessel
			//   the alternative is to scan the vessel for ModuleCommand, but that is slower, and rescue vessels have no module command
			// - flags have type set to 'station' for a single update, can still be detected as they have vesselID == 0
			switch(v.vesselType)
			{
				case VesselType.Debris:
				case VesselType.Flag:
				case VesselType.SpaceObject:
				case VesselType.Unknown:
				case VesselType.DeployedSciencePart:
					return false;
			}

			// [disabled] when going to eva (and possibly other occasions), for a single update the vessel is not properly set
			// this can be detected by vessel.distanceToSun being 0 (an impossibility otherwise)
			// in this case, just wait a tick for the data being set by the game engine
			// if (v.loaded && v.distanceToSun <= double.Epsilon)
			//	return false;

			//
			//if (!v.loaded && v.protoVessel == null)
			//	continue;

			// the vessel is valid
			return true;
		}



		internal static bool IsControlUnit(Vessel v)
		{
			return Serenity.GetScienceCluster(v) != null;
		}

		internal static bool IsPowered(Vessel v)
		{
			var cluster = Serenity.GetScienceCluster(v);
			if (cluster != null)
				return cluster.IsPowered;
			return ResourceCache.GetResource(v, "ElectricCharge").Amount > double.Epsilon;
		}

		internal static Guid VesselID(Vessel v)
		{
			// Lesson learned: v.persistendId is not unique. Far from it, in fact.

			// neither is this ----vvv (see https://github.com/steamp0rt/Kerbalism/issues/370)
			//byte[] b = v.id.ToByteArray();
			//UInt64 result = BitConverter.ToUInt64(b, 0);
			//result ^= BitConverter.ToUInt64(b, 8);
			//return result;
			// --------------------^^^

			// maybe this?
			// return RootID(v); // <-- nope. not unique.
			return v.id;
		}

		internal static Guid VesselID(ProtoVessel pv)
		{
			// nope
			//byte[] b = pv.vesselID.ToByteArray();
			//UInt64 result = BitConverter.ToUInt64(b, 0);
			//result ^= BitConverter.ToUInt64(b, 8);
			//return result;
			//return pv.protoPartSnapshots[pv.rootIndex].flightID;
			return pv.vesselID;
		}

		static Vessel CommNodeToVessel(CommNode node)
		{
			// Iterating over all vessels will work for recovering the vessel from a CommNode.However,
			// since CommNodes are created when Vessels are, you can almost certainly cache this in a
			// reasonable manner.
			// (Vessel creates a CommNetVessel which creates the CommNode.They're established no
			// later than OnStart())
			// We would either need something to monitor new Vessel creation (ie after staging events)
			// OR you want a fallback for cache misses.

			// Is is home return null
			if (node.isHome) return null;

			foreach (Vessel v in FlightGlobals.Vessels)
			{
				if (!IsVessel(v)) continue;

				if (AreSame(node, v.connection.Comm))
				{
					return v;
				}
			}

			Logging.Log("The node " + node.name + " is not valid.");
			return null;
		}

		static bool AreSame(CommNode a, CommNode b)
		{
			if (a == null || b == null)
			{
				return false;
			}

			return a.precisePosition == b.precisePosition;
		}
		#endregion

		#region PART
		///<summary>get list of parts recursively, useful from the editors</summary>
		internal static List<Part> GetPartsRecursively(Part root)
		{
			List<Part> ret = new List<Part>
			{
				root
			};
			foreach (Part p in root.children)
			{
				ret.AddRange(GetPartsRecursively(p));
			}
			return ret;
		}

		///<summary>return the name (not the title) of a part</summary>
		internal static string PartName(Part p)
		{
			return p.partInfo.name;
		}

		static int CrewCount(Part part)
		{
			// outside of the editors, it is easy
			if (!GameLogic.IsEditor())
			{
				return part.protoModuleCrew.Count;
			}

			// in the editor we need something more involved
			Int64 part_id = 4294967296L + part.GetInstanceID();
			var manifest = KSP.UI.CrewAssignmentDialog.Instance.GetManifest();
			var part_manifest = manifest.GetCrewableParts().Find(k => k.PartID == part_id);
			if (part_manifest != null)
			{
				int result = 0;
				foreach (var s in part_manifest.partCrew)
				{
					if (!string.IsNullOrEmpty(s)) result++;
				}
				return result;
			}

			return 0;
		}

		///<summary>return true if a part is manned, even in the editor</summary>
		internal static bool IsCrewed(Part p)
		{
			return CrewCount(p) > 0;
		}

		/// <summary>
		/// In the editor, remove the symmetry constraint for this part and its symmetric counterparts. 
		/// This method is available in stock (Part.RemoveFromSymmetry()) since 1.7.2, copied here for 1.4-1.6 compatibility
		/// </summary>
		internal static void EditorClearSymmetry(Part part)
		{
			part.CleanSymmetryReferences();
			if (part.stackIcon != null)
			{
				part.stackIcon.RemoveIcon();
				part.stackIcon.CreateIcon();
				if (StageManager.Instance != null) StageManager.Instance.SortIcons(true);
			}
			EditorLogic.fetch.SetBackup();
		}

		/// <summary>
		/// Return true if the Part Action Window for this part is shown, false otherwise
		/// </summary>
		internal static bool IsPAWVisible(this Part part)
		{
			return part.PartActionWindow != null && part.PartActionWindow.isActiveAndEnabled;
		}

		#endregion

		#region MODULE
		///<summary>
		/// return all modules implementing a specific type in a vessel
		/// note: disabled modules are not returned
		/// </summary>
		internal static List<T> FindModules<T>(Vessel v) where T : class
		{
			List<T> ret = new List<T>();
			for (int i = 0; i < v.parts.Count; ++i)
			{
				Part p = v.parts[i];
				for (int j = 0; j < p.Modules.Count; ++j)
				{
					PartModule m = p.Modules[j];
					if (m.isEnabled)
					{
						if (m is T t)
							ret.Add(t);
					}
				}
			}
			return ret;
		}

		internal static bool HasPart(Vessel v, string part_name)
		{
			if (Cache.HasVesselObjectsCache(v, "has_part:" + part_name))
				return Cache.VesselObjectsCache<bool>(v, "has_part:" + part_name);

			bool ret = false;
			foreach(string name in Tokenize(part_name, ','))
			{
				if (v.loaded)
					ret = v.parts.Find(k => k.name.StartsWith(part_name, StringComparison.Ordinal)) != null;
				else
					ret = v.protoVessel.protoPartSnapshots.Find(k => k.partName.StartsWith(part_name, StringComparison.Ordinal)) != null;
				if (ret) break;
			}

			Cache.SetVesselObjectsCache(v, "has_part:" + part_name, ret);
			return ret;
		}

		/// <summary>
		/// return all proto modules with a specified name in a vessel.
		/// note: disabled modules are not returned
		/// </summary>
		internal static List<ProtoPartModuleSnapshot> FindModules(ProtoVessel v, string module_name)
		{
			var ret = Cache.VesselObjectsCache<List<ProtoPartModuleSnapshot>>(v, "mod:" + module_name);
			if (ret != null)
				return ret;

			ret = new List<ProtoPartModuleSnapshot>(8);
			for (int i = 0; i < v.protoPartSnapshots.Count; ++i)
			{
				ProtoPartSnapshot p = v.protoPartSnapshots[i];
				ret.AddRange(FindModules(p, module_name));
			}

			Cache.SetVesselObjectsCache(v, "mod:" + module_name, ret);
			return ret;
		}

		///<summary>
		/// return all proto modules with a specified name in a part
		/// note: disabled modules are not returned
		/// </summary>
		internal static List<ProtoPartModuleSnapshot> FindModules(ProtoPartSnapshot p, string module_name)
		{
			List<ProtoPartModuleSnapshot> ret = new List<ProtoPartModuleSnapshot>(8);
			for (int j = 0; j < p.modules.Count; ++j)
			{
				ProtoPartModuleSnapshot m = p.modules[j];
				if (m.moduleName == module_name && Proto.GetBool(m, "isEnabled"))
				{
					ret.Add(m);
				}
			}
			return ret;
		}

		///<summary>
		/// return true if a module implementing a specific type and satisfying the predicate specified exist in a vessel
		/// note: disabled modules are ignored
		///</summary>
		internal static bool HasModule<T>(Vessel v, Predicate<T> filter) where T : class
		{
			for (int i = 0; i < v.parts.Count; ++i)
			{
				Part p = v.parts[i];
				for (int j = 0; j < p.Modules.Count; ++j)
				{
					PartModule m = p.Modules[j];
					if (m.isEnabled)
					{
						if (m is T t && filter(t))
							return true;
					}
				}
			}
			return false;
		}

		///<summary>
		/// return true if a proto module with the specified name and satisfying the predicate specified exist in a vessel
		///note: disabled modules are not returned
		///</summary>
		internal static bool HasModule(ProtoVessel v, string module_name, Predicate<ProtoPartModuleSnapshot> filter)
		{
			for (int i = 0; i < v.protoPartSnapshots.Count; ++i)
			{
				ProtoPartSnapshot p = v.protoPartSnapshots[i];
				for (int j = 0; j < p.modules.Count; ++j)
				{
					ProtoPartModuleSnapshot m = p.modules[j];
					if (m.moduleName == module_name && Proto.GetBool(m, "isEnabled") && filter(m))
					{
						return true;
					}
				}
			}
			return false;
		}

		///<summary>used by ModulePrefab function, to support multiple modules of the same type in a part</summary>
		internal sealed class Module_prefab_data
		{
			internal int index;                         // index of current module of this type
			internal List<PartModule> prefabs;          // set of module prefabs of this type
		}

		///<summary>
		/// get module prefab
		///  This function is used to solve the problem of obtaining a specific module prefab,
		/// and support the case where there are multiple modules of the same type in the part.
		/// </summary>
		internal static PartModule ModulePrefab(List<PartModule> module_prefabs, string module_name, Dictionary<string, Module_prefab_data> PD)
		{
			// get data related to this module type, or create it
			Module_prefab_data data;
			if (!PD.TryGetValue(module_name, out data))
			{
				data = new Module_prefab_data
				{
					prefabs = module_prefabs.FindAll(k => k.moduleName == module_name)
				};
				PD.Add(module_name, data);
			}

			// return the module prefab, and increment module-specific index
			// note: if something messed up the prefab, or module were added dynamically,
			// then we have no chances of finding the module prefab so we return null
			return data.index < data.prefabs.Count ? data.prefabs[data.index++] : null;
		}
		#endregion

		#region RESOURCE
		/// <summary> Returns the amount of a resource in a part </summary>
		internal static double Amount(Part part, string resource_name, bool ignore_flow = false)
		{
			foreach (PartResource res in part.Resources)
			{
				if ((res.flowState || ignore_flow) && res.resourceName == resource_name) return res.amount;
			}
			return 0.0;
		}

		/// <summary> Returns the capacity of a resource in a part </summary>
		internal static double Capacity(Part part, string resource_name, bool ignore_flow = false)
		{
			foreach (PartResource res in part.Resources)
			{
				if ((res.flowState || ignore_flow) && res.resourceName == resource_name) return res.maxAmount;
			}
			return 0.0;
		}

		/// <summary> Returns the level of a resource in a part </summary>
		internal static double Level(Part part, string resource_name, bool ignore_flow = false)
		{
			foreach (PartResource res in part.Resources)
			{
				if ((res.flowState || ignore_flow) && res.resourceName == resource_name)
				{
					return res.maxAmount > double.Epsilon ? res.amount / res.maxAmount : 0.0;
				}
			}
			return 0.0;
		}

		/// <summary> Adds the specified resource amount and capacity to a part,
		/// the resource is created if it doesn't already exist </summary>
		///<summary>poached from https://github.com/blowfishpro/B9PartSwitch/blob/master/B9PartSwitch/Extensions/PartExtensions.cs
		internal static PartResource AddResource(Part p, string res_name, double amount, double capacity)
		{
			var reslib = PartResourceLibrary.Instance.resourceDefinitions;
			// if the resource is not known, log a warning and do nothing
			if (!reslib.Contains(res_name))
			{
				Logging.Log(Lib.BuildString("error while adding ", res_name, ": the resource doesn't exist"), Logging.LogLevel.Error);
				return null;
			}
			var resourceDefinition = reslib[res_name];

			amount = System.Math.Min(amount, capacity);
			amount = System.Math.Max(amount, 0);
			PartResource resource = p.Resources[resourceDefinition.name];

			if (resource == null)
			{
				resource = new PartResource(p);
				resource.SetInfo(resourceDefinition);
				resource.maxAmount = capacity;
				resource.amount = amount;
				resource.flowState = true;
				resource.isTweakable = resourceDefinition.isTweakable;
				resource.isVisible = resourceDefinition.isVisible;
				resource.hideFlow = false;
				p.Resources.dict.Add(resourceDefinition.name.GetHashCode(), resource);

				PartResource simulationResource = new PartResource(resource);
				simulationResource.simulationResource = true;
				p.SimulationResources?.dict.Add(resourceDefinition.name.GetHashCode(), simulationResource);

				// flow mode is a property that call some code using SimulationResource in its setter.
				// consequently it must be set after simulationResource is registered to avoid the following log error spam :
				// [PartSet]: Failed to add Resource XXXXX to Simulation PartSet:XX as corresponding Part XXXX SimulationResource was not found.
				resource.flowMode = PartResource.FlowMode.Both;

				GameEvents.onPartResourceListChange.Fire(p);
			}
			else
			{
				resource.maxAmount = capacity;

				PartResource simulationResource = p.SimulationResources?[resourceDefinition.name];
				if (simulationResource != null) simulationResource.maxAmount = capacity;

				resource.amount = amount;
			}

			return resource;
		}

		/// <summary> Removes the specified resource amount and capacity from a part,
		/// the resource is removed completely if the capacity reaches zero </summary>
		internal static void RemoveResource(Part p, string res_name, double amount, double capacity)
		{
			// if the resource is not in the part, do nothing
			if (!p.Resources.Contains(res_name))
				return;

			// get the resource
			var res = p.Resources[res_name];

			// reduce amount and capacity
			res.amount -= amount;
			res.maxAmount -= capacity;

			// clamp amount to capacity just in case
			res.amount = System.Math.Min(res.amount, res.maxAmount);

			// if the resource is empty
			if (res.maxAmount <= 0.005) //< deal with precision issues
			{
				var reslib = PartResourceLibrary.Instance.resourceDefinitions;
				var resourceDefinition = reslib[res_name];

				p.Resources.dict.Remove(resourceDefinition.name.GetHashCode());
				p.SimulationResources?.dict.Remove(resourceDefinition.name.GetHashCode());

				GameEvents.onPartResourceListChange.Fire(p);
			}
		}

		///<summary>note: the resource must exist</summary>
		static void SetResourceCapacity( Part p, string res_name, double capacity )
		{
			// if the resource is not in the part, log a warning and do nothing
			if (!p.Resources.Contains( res_name ))
			{
				Logging.Log( Lib.BuildString( "error while setting capacity for ", res_name, ": the resource is not in the part" ), Logging.LogLevel.Error);
				return;
			}

			// set capacity and clamp amount
			var res = p.Resources[res_name];
			res.maxAmount = capacity;
			res.amount = System.Math.Min( res.amount, capacity );
		}

		///<summary>note: the resource must exist</summary>
		internal static void SetResource( Part p, string res_name, double amount, double capacity ) //internal because it's used if compilation symbols KSP18 or KSP110 are true
		{
			// if the resource is not in the part, log a warning and do nothing
			if (!p.Resources.Contains( res_name ))
			{
				Logging.Log( Lib.BuildString( "error while setting capacity for ", res_name, ": the resource is not in the part" ), Logging.LogLevel.Error);
				return;
			}

			// set capacity and clamp amount
			var res = p.Resources[res_name];
			res.maxAmount = capacity;
			res.amount = System.Math.Min( amount, capacity );
		}

		/// <summary> Set flow of a resource in the specified part. Does nothing if the resource does not exist in the part </summary>
		internal static void SetResourceFlow(Part p, string res_name, bool enable)
		{
			// if the resource is not in the part, do nothing
			if (p.Resources.Contains( res_name ))
			{
				// set flow state
				var res = p.Resources[res_name];
				res.flowState = enable;
			} else {
				Logging.LogDebugStack("Resource " + res_name + " not in part " + p.name);
			}
		}

		/// <summary> Fills a resource in the specified part to its capacity </summary>
		internal static void FillResource(Part p, string res_name)
		{
			// if the resource is not in the part, do nothing
			if (p.Resources.Contains(res_name))
			{
				PartResource res = p.Resources[res_name];
				res.amount = res.maxAmount;
			}
			else {
				Logging.LogDebugStack("Resource " + res_name + " not in part " + p.name); }
		}

		/// <summary> Sets the amount of a resource in the specified part to zero </summary>
		internal static void EmptyResource(Part p, string res_name)
		{
			// if the resource is not in the part, do nothing
			if (p.Resources.Contains(res_name))
				p.Resources[res_name].amount = 0.0;
			else {
				Logging.LogDebugStack("Resource " + res_name + " not in part " + p.name); }
		}

		/// <summary> Set the enabled/disabled state of a process
		/// <para> Use the process_capacity parameter to set the pseudo resource amount for the process,
		/// an amount of 0.0 disables the process, any non-zero value is a multiplier of the process.
		/// </para> </summary>
		internal static void SetProcessEnabledDisabled(Part p, string res_name, bool enable, double process_capacity)
		{
			if (!p.Resources.Contains(res_name))
			{
				Lib.AddResource(p, res_name, 0.0, process_capacity);
			}

			if (enable)
			{
				SetResource(p, res_name, process_capacity, process_capacity);
			}
			else
			{
				// Never remove the resource capacity, otherwise checks against
				// the pseudo resource might fail
				SetResource(p, res_name, 0.0, process_capacity);
			}
		}

		/// <summary> Returns the definition of a resource, or null if it doesn't exist </summary>
		internal static PartResourceDefinition GetDefinition( string name )
		{
			// shortcut to the resource library
			var reslib = PartResourceLibrary.Instance.resourceDefinitions;

			// return the resource definition, or null if it doesn't exist
			return reslib.Contains( name ) ? reslib[name] : null;
		}

		/// <summary>Returns resource localized display name</summary>
		internal static string GetResourceDisplayName(string name)
		{
			var res = GetDefinition(name);
			return res == null ? "N.A. (" + name + ")" : res.displayName;
		}

		/// <summary> Returns name of propellant used on eva </summary>
		internal static string EvaPropellantName()
		{
			// first, get the kerbal eva part prefab
			Part p = PartLoader.getPartInfoByName( "kerbalEVA" ).partPrefab;

			// then get the KerbalEVA module prefab
			KerbalEVA m = p.FindModuleImplementing<KerbalEVA>();

			// finally, return the propellant name
			return m.propellantResourceName;
		}


		/// <summary> Returns capacity of propellant on eva </summary>
		internal static double EvaPropellantCapacity()
		{
			// first, get the kerbal eva part prefab
			Part p = PartLoader.getPartInfoByName( "kerbalEVA" ).partPrefab;

			// then get the first resource and return capacity
			return p.Resources.Count == 0 ? 0.0 : p.Resources[0].maxAmount;
		}
		#endregion

		#region SCIENCE DATA
		///<summary>return true if there is experiment data on the vessel</summary>
		internal static bool HasData( Vessel v )
		{
			// stock science system
			if (!Features.Science)
			{
				// if vessel is loaded
				if (v.loaded)
				{
					// iterate over all science containers/experiments and return true if there is data
					return Lib.HasModule<IScienceDataContainer>( v, k => k.GetData().Length > 0 );
				}
				// if not loaded
				else
				{
					// iterate over all science containers/experiments proto modules and return true if there is data
					return Lib.HasModule( v.protoVessel, "ModuleScienceContainer", k => k.moduleValues.GetNodes( "ScienceData" ).Length > 0 )
						|| Lib.HasModule( v.protoVessel, "ModuleScienceExperiment", k => k.moduleValues.GetNodes( "ScienceData" ).Length > 0 );
				}
			}
			// our own science system
			else
			{
				foreach (var drive in Drive.GetDrives(v, true))
					if (drive.files.Count > 0) return true;
				return false;
			}
		}

		///<summary>remove one experiment at random from the vessel</summary>
		internal static void RemoveData( Vessel v )
		{
			// stock science system
			if (!Features.Science)
			{
				// if vessel is loaded
				if (v.loaded)
				{
					// get all science containers/experiments with data
					List<IScienceDataContainer> modules = Lib.FindModules<IScienceDataContainer>( v ).FindAll( k => k.GetData().Length > 0 );

					// remove a data sample at random
					if (modules.Count > 0)
					{
						IScienceDataContainer container = modules[Random.RandomInt( modules.Count )];
						ScienceData[] data = container.GetData();
						container.DumpData( data[Random.RandomInt( data.Length )] );
					}
				}
				// if not loaded
				else
				{
					// get all science containers/experiments with data
					var modules = new List<ProtoPartModuleSnapshot>();
					modules.AddRange( Lib.FindModules( v.protoVessel, "ModuleScienceContainer" ).FindAll( k => k.moduleValues.GetNodes( "ScienceData" ).Length > 0 ) );
					modules.AddRange( Lib.FindModules( v.protoVessel, "ModuleScienceExperiment" ).FindAll( k => k.moduleValues.GetNodes( "ScienceData" ).Length > 0 ) );

					// remove a data sample at random
					if (modules.Count > 0)
					{
						ProtoPartModuleSnapshot container = modules[Random.RandomInt( modules.Count )];
						ConfigNode[] data = container.moduleValues.GetNodes( "ScienceData" );
						container.moduleValues.RemoveNode( data[Random.RandomInt( data.Length )] );
					}
				}
			}
			// our own science system
			else
			{
				// select a file at random and remove it
				foreach (var drive in Drive.GetDrives(v, true))
				{
					if (drive.files.Count > 0) //< it should always be the case
					{
						SubjectData filename = null;
						int i = Random.RandomInt(drive.files.Count);
						foreach (File file in drive.files.Values)
						{
							if (i-- == 0)
							{
								filename = file.subjectData;
								break;
							}
						}
						drive.files.Remove(filename);
						break;
					}
				}
			}
		}


		// -- TECH ------------------------------------------------------------------

		///<summary>return true if the tech has been researched</summary>
		internal static bool HasTech( string tech_id )
		{
			// if science is disabled, all technologies are considered available
			if (HighLogic.CurrentGame.Mode == Game.Modes.SANDBOX) return true;

			// if RnD is not initialized
			if (ResearchAndDevelopment.Instance == null)
			{
				// this should not happen, throw exception
				throw new Exception( "querying tech '" + tech_id + "' while TechTree is not ready" );
			}

			// get the tech
			return ResearchAndDevelopment.GetTechnologyState( tech_id ) == RDTech.State.Available;
		}

		///<summary>return number of techs researched among the list specified</summary>
		static int CountTech( string[] techs )
		{
			int n = 0;
			foreach (string tech_id in techs) n += HasTech( tech_id ) ? 1 : 0;
			return n;
		}
		#endregion

		#region ASSETS
		///<summary> Returns the path of the directory containing the DLL </summary>
		static string Directory()
		{
			string dll_path = Assembly.GetExecutingAssembly().Location;
			return dll_path.Substring( 0, dll_path.LastIndexOf( Path.DirectorySeparatorChar ) );
		}

		///<summary> Loads a .png texture from the folder defined in <see cref="Textures.TexturePath"/> </summary>
		internal static Texture2D GetTexture( string name, int width = 16, int height = 16 )
		{
			Texture2D texture = new Texture2D( width, height, TextureFormat.ARGB32, false );
			ImageConversion.LoadImage(texture, System.IO.File.ReadAllBytes(Textures.TexturePath + name + ".png"));
			return texture;
		}

		///<summary> Returns a scaled copy of the source texture </summary>
		static Texture2D ScaledTexture( Texture2D src, int width, int height, FilterMode mode = FilterMode.Trilinear )
		{
			ScaleWithGPU( src, width, height, mode );

			Texture2D texture = new Texture2D( width, height, TextureFormat.ARGB32, false );
			texture.Resize( width, height );
			texture.ReadPixels( new Rect( 0, 0, width, height ), 0, 0, true );
			return texture;
		}

		///<summary> Scales the texture data of the source texture </summary>
		internal static void ScaleTexture( Texture2D texture, int width, int height, FilterMode mode = FilterMode.Trilinear )
		{
			ScaleWithGPU( texture, width, height, mode );

			texture.Resize( width, height );
			texture.ReadPixels( new Rect( 0, 0, width, height ), 0, 0, true );
			texture.Apply( true );
		}

		///<summary>Renders the source texture into the RTT - used by the scaling methods ScaledTexture() and ScaleTexture() </summary>
		static void ScaleWithGPU( Texture2D src, int width, int height, FilterMode fmode )
		{
			src.filterMode = fmode;
			src.Apply( true );

			RenderTexture rtt = new RenderTexture( width, height, 32 );
			Graphics.SetRenderTarget( rtt );
			GL.LoadPixelMatrix( 0, 1, 1, 0 );
			GL.Clear( true, true, new Color( 0, 0, 0, 0 ) );
			Graphics.DrawTexture( new Rect( 0, 0, 1, 1 ), src );
		}

		/// <summary>
		/// This makes Kerbalism possibly future-proof for new KSP versions, without requiring user
		/// intervention. With this, chances are that older Kerbalism versions will continue to work
		/// with newer KSP versions (until now the shader folder had to be copied).
		/// <para>
		/// Since KSP 1.5 (and possibly before), it has not been necessary to recompile the shaders.
		/// Kerbalism contained the same set of shader files for 1.5, 1.6, 1.7, 1.8 and 1.9. Chances
		/// are that future versions of KSP will still continue to work with the old shaders. To avoid
		/// the need to keep multiple copies of the same files, or manually rename the shader folder
		/// after a KSP update, use the default shader folder for all versions. If needed, this can be
		/// changed for future versions if they ever should require a new set of shaders.
		/// </para>
		/// </summary>
		static string GetShaderPath()
		{
			string platform = "windows";
			if (Application.platform == RuntimePlatform.LinuxPlayer) platform = "linux";
			else if (Application.platform == RuntimePlatform.OSXPlayer) platform = "osx";

			int version = Versioning.version_major * 100 + Versioning.version_minor;

			string shadersFolder;
			switch (version)
			{
				// should it ever be necessary...
				//case 105: // 1.5
				//case 106: // 1.6
				//case 107: // 1.7
				//case 108: // 1.8
				//case 109: // 1.9
				//	shadersFolder = "15";
				//	break;
				//case 110: // 1.10
				//	shadersFolder = "110";
				//	break;
				default:
					shadersFolder = "15";
					break;
			}

			return KSPUtil.ApplicationRootPath + "GameData/Kerbalism/Shaders/" + shadersFolder + "/_" + platform;
		}

		static Dictionary<string, Material> shaders;
		///<summary> Returns a material from the specified shader </summary>
		internal static Material GetShader( string name )
		{
			if (shaders == null)
			{
				shaders = new Dictionary<string, Material>();
#pragma warning disable CS0618 // WWW is obsolete
				using (WWW www = new WWW("file://" + GetShaderPath()))
#pragma warning restore CS0618
				{
					AssetBundle bundle = www.assetBundle;
					Shader[] pre_shaders = bundle.LoadAllAssets<Shader>();
					foreach (Shader shader in pre_shaders)
					{
						string key = shader.name.Replace("Custom/", string.Empty);
						if (shaders.ContainsKey(key))
							shaders.Remove(key);
						shaders.Add(key, new Material(shader));
					}
					bundle.Unload(false);
					www.Dispose();
				}
			}

			Material mat;
			if (!shaders.TryGetValue( name, out mat ))
			{
				throw new Exception( "shader " + name + " not found" );
			}
			return mat;
		}
		#endregion

		#region CONFIG
		///<summary>get a config node from the config system</summary>
		static ConfigNode ParseConfig( string path )
		{
			return GameDatabase.Instance.GetConfigNode( path ) ?? new ConfigNode();
		}

		///<summary>get a set of config nodes from the config system</summary>
		internal static ConfigNode[] ParseConfigs( string path )
		{
			return GameDatabase.Instance.GetConfigNodes( path );
		}

		///<summary>get a value from config</summary>
		internal static T ConfigValue<T>( ConfigNode cfg, string key, T def_value )
		{
			try
			{
				return cfg.HasValue( key ) ? (T) Convert.ChangeType( cfg.GetValue( key ), typeof( T ) ) : def_value;
			}
			catch (Exception e)
			{
				Logging.Log( "error while trying to parse '" + key + "' from " + cfg.name + " (" + e.Message + ")", Logging.LogLevel.Warning);
				return def_value;
			}
		}

		///<summary>get an enum from config</summary>
		internal static T ConfigEnum<T>( ConfigNode cfg, string key, T def_value )
		{
			try
			{
				return cfg.HasValue( key ) ? (T) Enum.Parse( typeof( T ), cfg.GetValue( key ) ) : def_value;
			}
			catch (Exception e)
			{
				Logging.Log( "invalid enum in '" + key + "' from " + cfg.name + " (" + e.Message + ")", Logging.LogLevel.Warning);
				return def_value;
			}
		}
		#endregion

		#region PROTO
		internal static class Proto
		{
			internal static bool GetBool( ProtoPartModuleSnapshot m, string name, bool def_value = false )
			{
				bool v;
				string s = m.moduleValues.GetValue( name );
				return s != null && bool.TryParse( s, out v ) ? v : def_value;
			}

			internal static uint GetUInt( ProtoPartModuleSnapshot m, string name, uint def_value = 0 )
			{
				uint v;
				string s = m.moduleValues.GetValue( name );
				return s != null && uint.TryParse( s, out v ) ? v : def_value;
			}

			internal static int GetInt(ProtoPartModuleSnapshot m, string name, int def_value = 0)
			{
				int v;
				string s = m.moduleValues.GetValue(name);
				return s != null && int.TryParse(s, out v) ? v : def_value;
			}

			internal static float GetFloat( ProtoPartModuleSnapshot m, string name, float def_value = 0.0f )
			{
				// note: we set NaN and infinity values to zero, to cover some weird inter-mod interactions
				float v;
				string s = m.moduleValues.GetValue( name );
				return s != null && float.TryParse( s, out v ) && !float.IsNaN( v ) && !float.IsInfinity( v ) ? v : def_value;
			}

			internal static double GetDouble( ProtoPartModuleSnapshot m, string name, double def_value = 0.0 )
			{
				// note: we set NaN and infinity values to zero, to cover some weird inter-mod interactions
				double v;
				string s = m.moduleValues.GetValue( name );
				return s != null && double.TryParse( s, out v ) && !double.IsNaN( v ) && !double.IsInfinity( v ) ? v : def_value;
			}

			internal static string GetString( ProtoPartModuleSnapshot m, string name, string def_value = "" )
			{
				string s = m.moduleValues.GetValue( name );
				return s ?? def_value;
			}

			internal static T GetEnum<T>(ProtoPartModuleSnapshot m, string name, T def_value)
			{
				UnityEngine.Profiling.Profiler.BeginSample("Kerbalism.Lib.Proto.GetEnum");
				string s = m.moduleValues.GetValue(name);
				if (s != null && Enum.IsDefined(typeof(T), s))
				{
					T forprofiling = (T)Enum.Parse(typeof(T), s);
					UnityEngine.Profiling.Profiler.EndSample();
					return forprofiling;
				}
				UnityEngine.Profiling.Profiler.EndSample();
				return def_value;
			}

			internal static T GetEnum<T>(ProtoPartModuleSnapshot m, string name)
			{
				string s = m.moduleValues.GetValue(name);
				if (s != null && Enum.IsDefined(typeof(T), s))
					return (T)Enum.Parse(typeof(T), s);
				return (T)Enum.GetValues(typeof(T)).GetValue(0);
			}

			///<summary>set a value in a proto module</summary>
			internal static void Set<T>( ProtoPartModuleSnapshot module, string value_name, T value )
			{
				module.moduleValues.SetValue( value_name, value.ToString(), true );
			}
		}
		#endregion
	}

	#region UTILITY CLASSES

	internal class ObjectPair<T, U>
	{
		internal T Key;
		internal U Value;

		internal ObjectPair(T key, U Value)
		{
			this.Key = key;
			this.Value = Value;
		}
	}

#endregion


} // KERBALISM
